El análisis de algoritmos no se queda solo en lo que la teoría predice con la notación asintótica. 
En la práctica influyen muchos otros factores: las constantes ocultas, el manejo de memoria, 
la forma en que se implementa cada rutina e incluso las características del hardware donde se ejecuta. 
Por eso resulta necesario complementar el estudio teórico con experimentos que muestren cómo se comportan realmente los algoritmos en condiciones concretas.

En esta tarea se trabajó con dos problemas clásicos: el ordenamiento de arreglos de enteros y la multiplicación de matrices cuadradas. 
Para el primero se consideraron distintos enfoques, desde métodos básicos como \texttt{InsertionSort}, 
hasta algoritmos eficientes como \texttt{MergeSort}, \texttt{QuickSort}, el experimental \texttt{PandaSort} y la función optimizada \texttt{std::sort}. 
Para el segundo se compararon las aproximaciones \texttt{Naive} y \texttt{Strassen}, 
dos alternativas que ilustran la diferencia entre un método directo y uno que busca reducir la complejidad asintótica a costa de mayor uso de memoria.

El objetivo principal es contrastar lo que se espera en teoría con lo que realmente ocurre al ejecutar los algoritmos sobre conjuntos de datos generados bajo distintos escenarios. 
De esta forma, se busca mostrar que la elección de un algoritmo no depende solo de su complejidad matemática, 
sino también de las condiciones específicas del problema y de los recursos disponibles en la práctica.
