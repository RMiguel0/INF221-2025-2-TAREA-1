El análisis experimental permitió contrastar las complejidades teóricas de los algoritmos con su desempeño práctico. 
En el caso del ordenamiento, los resultados confirmaron la superioridad de los algoritmos $O(n\log n)$ frente a los cuadráticos: 
\texttt{InsertionSort} se volvió impracticable en instancias grandes, mientras que \texttt{MergeSort}, \texttt{QuickSort} y especialmente \texttt{std::sort} 
mostraron tiempos eficientes y un uso de memoria acorde a sus diseños. 
El algoritmo \texttt{PandaSort}, en cambio, evidenció un comportamiento inferior, lo que subraya la dificultad de competir con métodos clásicos ya optimizados.

En cuanto a la multiplicación de matrices, el algoritmo \texttt{Naive} resultó más eficiente en los tamaños considerados, 
a pesar de su complejidad asintótica $O(n^3)$. 
Esto se debe a que \texttt{Strassen}, aunque teóricamente más rápido ($O(n^{2.81})$), introduce un costo adicional significativo en operaciones intermedias 
y uso de memoria, lo que impide que su ventaja teórica se materialice en escalas moderadas. 
Además, la necesidad de múltiples matrices temporales genera un sobrecosto en espacio que se refleja empíricamente en los gráficos.

En síntesis, los experimentos evidencian que la complejidad asintótica no basta para predecir el rendimiento real de un algoritmo: 
las constantes ocultas, el manejo de memoria y los detalles de implementación son determinantes en la práctica. 
Los resultados cumplen con el objetivo de la tarea al conectar teoría y práctica, mostrando cómo los límites del análisis asintótico se revelan 
en escenarios experimentales concretos.
